---
title: Time-Locked Accounts
hide_title: true
---

:::info

Please note that zkApp programmability is not yet available on Mina Mainnet, but zkApps can now be deployed to Berkeley Testnet.

:::

# Time-Locked Accounts

Time-locking allows you to pay someone MINA or other tokens, which are subject to a vesting schedule. This means that the tokens are initially locked, and only become available for withdrawal after a certain time, or gradually according to a certain schedule.

The zkApp feature that enables time-locking is the `timing` field, which is present on every account. It look like this:

```ts
type Account = {
  // ...
  timing: {
    isTimed: Bool;
    initialMinimumBalance: UInt64;
    cliffTime: UInt32;
    cliffAmount: UInt64;
    vestingPeriod: UInt32;
    vestingIncrement: UInt64;
  };
};
```

`isTimed` tells us whether this account is subject to any time-locking. The other fields are parameters that allow us to define a vesting schedule in a very flexible manner. We will explain them in detail below. By default, an account has `isTimed: false`; in that case, the other fields are dummy values.

At a glance, this graph shows you how each of the timing parameters affect the vesting schedule:

<figure>
  <img
    src="/img/10_time_locked_accounts.png"
    width="95%"
    alt="Timing parameters"
  />
</figure>

The red cross on the left marks the point in time where the `timing` field is set and `isTimed` switches from false to true. The blue line shows how the amount of unlocked tokens increases over time, until it finally reaches its maximum value and stays flat. At this point, `isTimed` flips from `true` back to `false`, because there no longer are any tokens locked.

As you can see, the maximum amount of unlocked tokens is defined by the `initialMinimumBalance`. It is called "initialMinimumBalance" because, even though the tokens show up in the balance, they can't be withdrawn - in other words, the account has a a non-zero _minimum balance_. Initially, that minimum balance is equal to the amount of tokens locked (= initial minimum balance). Over time, the minimum balance decreases until it hits zero, which is the condition that makes `isTimed` false again.

Here's a breakdown of all timing fields:

- **cliff time**: the initial time length during which no tokens whatsoever are unlocked.
  - note: "time" is measured in slots (in Mina, currently 1 slot = 3 minutes).
- **cliff amount**: the amount of tokens unlocked after the cliff time ended.
  - if this is greater or equal the initial minimum balance, _all_ tokens get unlocked after the cliff time.
- **vesting period**: after the cliff time, tokens get unlocked periodically in a fixed interval, by a fixed amount. The vesting period is the length of that interval.
- **vesting increment**: the amount by which tokens get unlocked after each vesting period

It's important to note that there is only ever one vesting schedule per account and it can't be changed during the vesting period. So, whenever `isTimed` is true, all the timing fields are immutable. When all tokens are unlocked and `isTimed` flips back to `false`, the account timing becomes mutable again.

### Setting timing in SnarkyJS

In SnarkyJS, `timing` is one of the account fields that can be updated by an account update:

```ts
accountUpdate.account.timing.set({ initialMinimumBalance, cliffTime, ...etc });
```

You need to set all timing parameters except `isTimed`, which is managed by the protocol automatically.

Let's see how to correctly implement some simple example use cases.

**Use case 1: all tokens unlocked after 1 week**. If you don't care about the linear vesting schedule and just want all tokens unlock after a certain time, then the only parameters you really care about are `cliffTime` and `cliffAmount`. We also want to set `initialMinimumBalance` equal to `cliffAmount` to ensure all tokens are unlocked at this point. The values `vestingPeriod` and `vestingIncrement` do not matter so we set them to 1 and 0, respectively:

```ts
// example: 10 locked MINA
const totalAmount = UInt64.from(10e9);

// example: tokens locked for one week
const cliffTime = UInt32.from((60 / 3) * 24 * 7);

accountUpdate.account.timing.set({
  initialMinimumBalance: totalAmount,
  cliffTime,
  cliffAmount: totalAmount,
  vestingPeriod: UInt32.from(1), // 1 because an interval of length 0 is ill-defined behaviour
  vestingIncrement: UInt64.from(0),
});

// we also have to send the locked tokens to that account
this.send({ to: accountUpdate, amount: totalAmount });
```

**Use case 2: linear vesting schedule of 1 year duration**. The second example is one where we don't careabout a "cliff", but just want a given amount to vest linearly over the time span of 1 year. We set the `vestingPeriod` to 1 month so that new tokens get unlocked every month. The `vestingIncrement` is set to the total amount, divided by 12, so that the whole schedule will be finished after 12 months. Both `cliffTime` and `cliffAmount` can just be set to 0.

```ts
// example: 100000 locked MINA
const totalAmount = UInt64.from(100000e9);

// calculate 1 month in slots
const vestingPeriod = UInt32.from(Math.round(((60 / 3) * 24 * 365) / 12));

// 1/12th of tokens unlocked every month
const vestingIncrement = UInt64.from(Math.round(totalAmount / 12));

accountUpdate.account.timing.set({
  initialMinimumBalance: totalAmount,
  cliffTime: UInt32.from(0),
  cliffAmount: UInt64.from(0),
  vestingPeriod,
  vestingIncrement,
});

// send the locked tokens
this.send({ to: accountUpdate, amount: cliffAmount });
```
