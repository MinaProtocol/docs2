---
title: FAQ
---

## Does SnarkyJS compile my JavaScript code to an arithmetic circuit?

No, SnarkyJS **does NOT compile into anything else**! In contrast to other zk ecosystems, SnarkyJS is just a JS library. It creates zk circuits from user code by _executing_ that code. If you have a smart contract with a `@method myMethod()`, for example, we will simply call `myMethod();` during proof generation.

This works because SnarkyJS sets up some global state - a "circuit" - where it collects variables and constraints. The use of functions like `Field.mul` or `Bool.assertEquals` inside your smart contract methods will add corresponding variables and constraints to the global circuit.

This has some implications:

- In order to turn your logic into a proof, you'll need to use SnarkyJS built-in datatypes such as `Field`. You'll also need to use the SnarkyJS functions that operate on them, like `Field.mul()`.
  - A statement like `x.mul(y)` will add a generic PLONK gate to your circuit. It will also return a variable that you can use in further statements, which will get wired to the multiplication gate.
  - Some SnarkyJS functions allow you to turn normal JS datatypes into `Field` elements and back, such as `Field.toString()`. These functions don't add anything to your circuit. They will typically clarify this in a doc-comment.
- Conventional JS code such as `'hello world'.split('').join(' ')` that doesn't use SnarkyJS built-ins will not be included in your zk proof in any way since it will not add anything to your circuit.
  - Why? Because it doesn't call any of the functions that build the circuit.
  - There's nothing wrong with having circuit-less code like the above inside your method, as long as you're aware of what it's (not) doing.

Let's look at some examples. Here we assert that a Field element `x` is not equal to `5`, `10` or `15`:

```ts
// good
for (let y of [5, 10, 15]) {
  x.equals(y).assertFalse();
}
```

It's fine to use JS language constructs such as the for-loop above to stitch together the right SnarkyJS commands. But you can't use the value of Field elements to determine what constraints to add. The following statement won't work, even though `b` is a SnarkyJS `Bool`:

```ts
// bad
if (b.toBoolean()) x.assertEquals(10);
```

This example fails for two reasons:

1. Circuit code has to interact with SnarkyJS built-in types. An expression like `b.toBoolean()` will throw an error during `SmartContract.compile()` (which generates the prover and verification keys) because you can't read out the values of variables like that. This is because during `compile()`, variables like `b` don't have any JS values attached to them; they represent abstract variables used to build up an abstract arithmetic circuit.
2. More subtly, your methods must create the same constraints every time because a proof cannot be verified against a verification key for a differing set of constraints. The code above adds an `assertEquals` _on condition of_ the value of `b`. This can lead to constraints varying between executions of the proof.

Takeaway: Conventional JS constructs only work if they don't interact with the concrete zk logic being written in SnarkyJS.
